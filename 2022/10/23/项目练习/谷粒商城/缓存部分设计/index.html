<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>谷粒商城-分布式缓存设计 | 月の子豚小屋</title><meta name="keywords" content="SpringCloud Redis"><meta name="author" content="moon"><meta name="copyright" content="moon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis 缓存为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而 db 数据库承担数据落盘工作。  那么哪些数据适合放入缓存呢？ 1）即时性、数据一致性要求不高的； 2）访问量大且更新频率不高的数据（读多，写少的情况） 。 拥有缓存的查询逻辑执行过程：  可以使用本地缓存（例如 Map 缓存），在负载均衡情况下可能会出现 数据不一致 的情况，因此分布式情况下应该使用分布式缓存方案">
<meta property="og:type" content="article">
<meta property="og:title" content="谷粒商城-分布式缓存设计">
<meta property="og:url" content="http://localhost:4000/2022/10/23/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="月の子豚小屋">
<meta property="og:description" content="Redis 缓存为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而 db 数据库承担数据落盘工作。  那么哪些数据适合放入缓存呢？ 1）即时性、数据一致性要求不高的； 2）访问量大且更新频率不高的数据（读多，写少的情况） 。 拥有缓存的查询逻辑执行过程：  可以使用本地缓存（例如 Map 缓存），在负载均衡情况下可能会出现 数据不一致 的情况，因此分布式情况下应该使用分布式缓存方案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg">
<meta property="article:published_time" content="2022-10-23T04:57:14.551Z">
<meta property="article:modified_time" content="2022-10-24T14:24:02.888Z">
<meta property="article:author" content="moon">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="SpringBoot">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="Spring Cache">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg"><link rel="shortcut icon" href="https://w.wallhaven.cc/full/8o/wallhaven-8o2v82.jpg"><link rel="canonical" href="http://localhost:4000/2022/10/23/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '谷粒商城-分布式缓存设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-24 22:24:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic1.imgdb.cn/item/6337ca6e16f2c2beb17d8731.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">月の子豚小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">谷粒商城-分布式缓存设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-23T04:57:14.551Z" title="发表于 2022-10-23 12:57:14">2022-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-24T14:24:02.888Z" title="更新于 2022-10-24 22:24:02">2022-10-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/">项目练习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%B0%9A%E7%A1%85%E8%B0%B7/">谷粒商城-尚硅谷</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="谷粒商城-分布式缓存设计"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h2><p>为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而 db 数据库承担数据落盘工作。 </p>
<p>那么哪些数据适合放入缓存呢？</p>
<p>1）即时性、数据一致性要求不高的；</p>
<p>2）访问量大且更新频率不高的数据（读多，写少的情况） 。</p>
<p>拥有缓存的查询逻辑执行过程：</p>
<p><img src="https://pic1.imgdb.cn/item/635504f116f2c2beb1345ea4.png"></p>
<p>可以使用本地缓存（例如 Map 缓存），在负载均衡情况下可能会出现 <code>数据不一致</code> 的情况，因此分布式情况下应该使用分布式缓存方案（例如 <code>Redis</code> ）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12374488/1630841046633-826f06c2-b178-4c26-8ea6-a069cfb422eb.png" alt="image.png"></p>
<h3 id="整合-Redis"><a href="#整合-Redis" class="headerlink" title="整合 Redis"></a>整合 Redis</h3><p>1、引入 redis-starter 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、配置 redis 连接信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">redis:</span> </span><br><span class="line">    	<span class="attr">host:</span> <span class="number">8.142</span><span class="number">.92</span><span class="number">.222</span></span><br><span class="line">    	<span class="attr">port:</span> <span class="number">6666</span></span><br></pre></td></tr></table></figure>

<p>测试使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopProductApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引入 redis 操作对象：StringRedisTemplate</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">		ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();</span><br><span class="line">		<span class="comment">//保存数据</span></span><br><span class="line">		ops.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world_&quot;</span>+ UUID.randomUUID().toString());</span><br><span class="line">		<span class="comment">//查询数据</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> ops.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		System.out.println(hello);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、整改原来的代码，加入 Redis 缓存功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">TODO:</span>压力测试时发现会产生堆外内存溢出，主要是因为 Boot 默认使用 lettuce 作为操作 redis 的客户端</span></span><br><span class="line"><span class="comment"> * 1）lettuce 底层使用 Netty 进行网络通信</span></span><br><span class="line"><span class="comment"> * 2)lettuce 本身的 bug 导致 Netty 堆外内存（直接内存）溢出，因为如果没有指定对外内存，默认会使用设置的 -Xmx 的大小</span></span><br><span class="line"><span class="comment"> * 解决方案：</span></span><br><span class="line"><span class="comment"> * 1）调整 -Dio.netty.maxDirectMemory 的大小</span></span><br><span class="line"><span class="comment"> * 2）升级 lettuce，或者切换使用 Jedis 老版的方案（此处我并没有修改）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatelogJson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//加入缓存逻辑的实现:需要注意 Json 格式的相互转化（序列化和反序列化问题）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogJson</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;catelogJson&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(catelogJson))&#123;</span><br><span class="line">        <span class="comment">//判断缓存中是否存在,如果没有则从数据库查询，并将查询到的数据转为 Json 插入到缓存</span></span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catelogJsonFromDB = <span class="built_in">this</span>.getCatelogJsonFromDB();</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;catelogJson&quot;</span>, JSON.toJSONString(catelogJsonFromDB));</span><br><span class="line">        log.debug(<span class="string">&quot;完成 Redis 缓存的更新&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> catelogJsonFromDB;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = JSON.parseObject(catelogJson, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;()&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从数据库查询并封装分类数据</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatelogJsonFromDB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//原来的 getCatelogJson 函数从数据库查询即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h3><p><code>缓存穿透</code>问题是指查询一个一定不存在的数据，因此<code>缓存肯定查不到，数据库也查不到</code>，那么就会导致每次请求都还是会打到数据库，可能会导致数据库崩溃，失去了缓存的意义。可采用 <code>缓存 null 结果或是标志位缓存，并加入短暂过期时间</code> 的方案来解决。</p>
<p><code>缓存雪崩</code>问题是指设置缓存时采用相同的的过期时间，也就导致了<code>缓存大面积集体失效</code>，数据库压力骤增，甚至崩溃。可采用 <code>失效时间基础上增加随机值，让缓存过期时间重复率下降</code> 的方式来解决。</p>
<p><code>缓存击穿</code>问题是指某一个高频热点数据缓存失效时突然来了大量请求该数据，呆滞缓存击穿。开率使用 <code>加锁</code> 的方式使请求串行执行来解决。</p>
<p>因此上面的缓存添加方式还需要优化：</p>
<p>1、添加缓存过期时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;catelogJson&quot;</span>, JSON.toJSONString(catelogJsonFromDB), <span class="number">1</span>, TimeUnit.DAYS);</span><br></pre></td></tr></table></figure>

<p>2、加锁：使用 <code>synchronized/Lock</code> 本地进程锁同步资源或是使用 <code>分布式锁</code>。</p>
<p>1）本地锁方案：如果是 <code>synchronized(this)</code> 或是直接加到方法上，由于 SpringBoot Bean 默认单例，因此能够实现加锁同步让请求串行执行。但是分布式场景下，某个服务都会是多个同时部署，但是 this 只代表当前容器里面的 Bean，因此只能锁住当前服务的该对象，也就是说还是会有多个请求能够打进系统，多少个服务就可能有多少个请求同时打进数据库，因此就需要 <code>分布式锁</code> 来整体控制请求 (实际上服务不多的情况下也可以接受)。</p>
<p>2）分布式锁方案：主要考虑使用 Redis 的 nx 操作来实现。</p>
<p>1 &gt; 首先考虑使用 Redis 的 <code>set nx 和 ex</code> 原子性命令来实现分布式锁，但是如果业务代码执行过程中出现异常或是执行业务时机器断电了，那么<code>释放锁过程就没有执行</code>，就可能会导致死锁，因此使用此种方式时<code>锁必须设定过期时间</code>（同时还必须和之前的操作是原子操作，避免命令之间出现故障不释放锁），能够自动删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">30</span>, TimeUnit.SECONDS);	<span class="comment">//加锁并同时设置过期时间</span></span><br><span class="line"><span class="keyword">if</span> (lock) &#123;  </span><br><span class="line">    <span class="comment">//加锁成功，执行业务</span></span><br><span class="line">    业务代码</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//说明有客户端先建立了连接，加锁失败，进行重试</span></span><br><span class="line">    <span class="keyword">return</span> getCatelogJson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 &gt; 但是设置锁的过期时间还会出现问题：业务未执行完成时锁已经过期，那么就可能导致很多问题：</p>
<ul>
<li>问题一：删除 redis 中已经过期不存在的数据。</li>
<li>问题二：锁最初被客户端 c1 拥有，锁过期时 c1 还未执行完毕，锁被其他 client 拿到，其他线程还未执行完毕自己的业务时，c1 又会执行删锁的逻辑，而且实际上<code>删除的是其他 client 拥有的锁</code>，那么就导致后面的 client 请求的锁同时失效，造成更多的 client 拿到锁，蝴蝶效应。</li>
</ul>
<p>那么实际上 lock 中的 value 就不能存储一个相同的锁标志位，而是应该给每个 client 一个特定的标志：<code>UUID</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (lock) &#123;</span><br><span class="line">    <span class="comment">//加锁成功，先执行业务，再释放锁</span></span><br><span class="line">    <span class="comment">// ......业务代码......</span></span><br><span class="line">    <span class="comment">// 当删除锁时则需要先判断目前的锁是不是自己放的那个锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockValue</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (uuid.equals(lockValue))&#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//说明有客户端先建立了连接，加锁失败，进行重试</span></span><br><span class="line">    <span class="keyword">return</span> getCatelogJson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	但实际上还是存在问题：假如业务执行完毕后，get(“lock”) 获取过程比较漫长(网络交互)，刚获取到 lock 值还没过期，但是在数据回传到业务代码时 lock 就过期了，同时另一个 client 设置的锁的 key 也叫 lock ，那么还是可能会删除其他 client 的锁。</p>
<p>​	而这种问题的解决办法就得<code>采用 Lua 脚本来将获取 lock 值和删除 lock 过程变为一个原子操作来解锁</code>。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (lock) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         //加锁成功，先执行业务，再释放锁</span><br><span class="line">         // ......业务代码......</span><br><span class="line">     &#125;finally &#123;</span><br><span class="line">         // 使用 Lua 脚本来实现原子操作删除锁</span><br><span class="line">         String luaScript = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">         redisTemplate.<span class="built_in">execute</span>(new DefaultRedisScript&lt;&gt;(luaScript, Long.class), Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    //说明有客户端先建立了连接，加锁失败，进行重试</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> getCatelogJson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 &gt; 使用封装好的方案：<code>Redisson 分布式锁</code> 方案。后续项目的分布式锁和分布式对象方案就是选择使用 Redisson 来实现。</p>
<h3 id="Redisson-方案实现"><a href="#Redisson-方案实现" class="headerlink" title="Redisson 方案实现"></a>Redisson 方案实现</h3><p>Redisson 就是在 Redis 基础上实现的 Java 语言的分布式锁的实现，提供了很多分布式服务。</p>
<p>1、引入 Redisson 的服务原生依赖（后续实际使用会引入 starter）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、配置 redisson ，编写 redisson 配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="comment">//注入 RedissonClient 对象：所有对 Redisson 的操作都是通过这个对象</span></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">//使用单节点 redis 模式并设置远程 redis 地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://8.142.92.222:6666&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、Redisson 可重入锁实现。</p>
<p>基于 Redisson 实现可重入锁基本和 Java 的 Lock 接口相同，并且实现了 JUC Lock 的锁，因此使用上也基本没有区别，可以无缝切换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取锁，锁名相同即同一把锁</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line">    <span class="comment">//阻塞式 &quot;等待&quot; 加锁后才能执行业务代码</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(Thread.currentThread().getName() + <span class="string">&quot;加锁成功!!!&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;开始执行业务代码......&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;执行业务代码完毕......&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁,推荐放在 finally 代码块</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.debug(Thread.currentThread().getName() + <span class="string">&quot;解锁成功!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启两个窗口执行 &#x2F;hello 请求，请求结果显示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http-nio-10001-exec-1加锁成功!!!</span><br><span class="line">开始执行业务代码......</span><br><span class="line">执行业务代码完毕......</span><br><span class="line">http-nio-10001-exec-1解锁成功!!!</span><br><span class="line">http-nio-10001-exec-2加锁成功!!!</span><br><span class="line">开始执行业务代码......</span><br><span class="line">执行业务代码完毕......</span><br><span class="line">http-nio-10001-exec-2解锁成功!!!</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.imgdb.cn/item/63563aa416f2c2beb19352c9.png"></p>
<p><code>[问题]</code> 假设解锁代码没有运行(断电等等故障问题时)，Redisson 会不会出现死锁呢？</p>
<p>实际上这个问题很容易演示，两个服务一起抢锁，停掉其中一个，发现另一个可以拿到锁，因此<code>没有死锁问题</code>。同时还会发现当不停刷新锁数据（模拟业务操作时间过长）时，锁的有效时间（默认有效时间 30s ）变长了，也就是<code>自动续期</code>，实际上这是因为 Redisson 的<code>看门狗机制</code> 。</p>
<p>1）锁的自动续期：如果业务超长，运行期间会自动给锁续上新的 30s，不用担心业务时间过长导致锁自动过期而被删除。</p>
<p>2）加锁的业务只要运行完成，就不会给锁自动续期，即使不手动释放锁，锁默认也会在30s以后自动删除。</p>
<blockquote>
<p>注意：如果指定锁key 的有效时间，那么<code>锁超时后就不会自动续期</code>，因此底层实际上就是调用 Lua 脚本来执行(未指定时间就会使用看门狗的默认时间 30s ，同时内部就会有定时任务( <code>看门狗时间/3</code> 执行一次)来重新设置过期时间为看门狗的默认时间)，因此需要注意自动解锁时间一定要大于业务的执行时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此最佳实践是应该指定过期时间，省掉整个自动续期的操作，来手动解锁。</p>
<p>3、Redisson 读写锁实现。</p>
<p>​	基于 Redis 的 Redisson 分布式可重入读写锁 <code>RReadWriteLock</code> Java对象实现了 <code>JUC.ReadWriteLock</code> 接口，其中读锁和写锁都继承了 RLock 接口，因此分布式Redisson 读写锁特性仍然是允许同时有多个读锁（共享锁）和一个写锁（排他锁）处于加锁状态 &#x3D;&#x3D;&#x3D;&#x3D;&gt; <code>读读并行，写读互斥，读写互斥，写写互斥</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;anyRWLock&quot;</span>);</span><br><span class="line">rwlock.readLock().lock();		<span class="comment">//加读锁</span></span><br><span class="line">rwlock.writeLock().lock();		<span class="comment">//加写锁</span></span><br></pre></td></tr></table></figure>



<p>4、Redisson 信号量 Semaphore 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/park&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RSemaphore</span> <span class="variable">park</span> <span class="operator">=</span> redissonClient.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    park.acquire(); <span class="comment">//阻塞获取一个信号量（占用一个车位）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;park&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/go&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">go</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RSemaphore</span> <span class="variable">park</span> <span class="operator">=</span> redissonClient.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    park.release(); <span class="comment">//释放一个信号量（释放一个车位）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;go&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此根据上面的案例可以发现，信号量还可以做 <code>限流操作</code>，限制信号量数量来做分布式限流。</p>
<p>5、Redisson 闭锁 CountDownLatch 实现类似于 JUC 的闭锁实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;my-countDownLatch&quot;</span>);</span><br><span class="line">latch.trySetCount(<span class="number">5</span>);</span><br><span class="line">latch.await();		<span class="comment">// 等待闭锁完成，计数到 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭锁计数操作时也就是获取 CountDownLatch 来释放</span></span><br><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;my-countDownLatch&quot;</span>);</span><br><span class="line">latch.countDown();	<span class="comment">//闭锁计数减1</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>使用 Redisson 来改造原来的业务代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatelogJsonWithRedisson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;catelogJson-lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catelogJsonFromDB = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">catelogJson</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;catelogJson&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(catelogJson))&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;缓存未命中，查询数据库&quot;</span>);</span><br><span class="line">            catelogJsonFromDB = <span class="built_in">this</span>.getCatelogJsonFromDB();</span><br><span class="line">            log.debug(<span class="string">&quot;完成 Redis 缓存的新增&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;缓存命中,直接从缓存中获取数据&quot;</span>);</span><br><span class="line">            catelogJsonFromDB = JSON.parseObject(catelogJson, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;()&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> catelogJsonFromDB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是当数据修改 update 时，就可能会出现 <code>数据一致性问题：缓存数据如何和数据库保持一致</code>？</p>
<p>1）<code>双写模式</code>：数据库更改完毕后，读取数据库数据来替换缓存中的数据。</p>
<p><img src="https://pic1.imgdb.cn/item/6356502016f2c2beb1cd1709.png"></p>
<p>2）<code>失效模式</code>：数据库更改完毕后，删除缓存中的数据，等待下一次主动查询时更新。</p>
<p><img src="https://pic1.imgdb.cn/item/6356502b16f2c2beb1cd3230.png"></p>
<p>但是这两种方案还是都存在 <code>暂时性的脏数据问题</code>，都会导致缓存不一致问题，即多个实例同时更新时会出现问题，但都是能够保证 <code>最终一致性</code> 的。</p>
<p>因此缓存一致性的的解决方案：</p>
<p>1）如果是用户维度的数据（个人信息、订单数据等等），并发几率小，则缓存数据加上过期时间每隔一段时间就触发读数据的 <code>自动更新缓存</code> 即可。</p>
<p>2）如果是菜单数据、商品介绍等<code>能够容忍长时间的缓存不一致</code>的基本数据，可以不考虑解决，但也可以使用 canal 订阅 binlog 日志的方式。</p>
<p><img src="https://media.ntan520.com/2022/03/bacbb42280b714a6240119de37e11b83.png" alt="Canal工作原理及使用插图2"></p>
<p>也就是说 <code>缓存数据 + 过期时间</code> 能够解决大部分业务对于缓存的要求，如果不能保证，可以通过 <code>加锁(特别是读写锁)</code> 来保证读读并发和读写互斥。</p>
<p><code>[总结]</code> 本系统中的数据一致性解决方案：所有数据设置过期时间（<code>失效模式</code>），读写数据时，加上 <code>分布式读写锁</code>，非常适用于本系统中经常读取数据的情况。</p>
<h2 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h2><p>在上面的开发中发现，缓存的处理代码基本都一样，肯定就需要考虑抽取公共工具类或是其他方案，而 <code>Spring Cache</code> 就是 Spring 整合缓存的一套方案，用来统一缓存的实现，主要就是通过 <code>Cache(实际存储)</code> 和 <code>CacheManager(定义规则，包括 RedisCacheManager )</code> 两个接口实现，一个 Manager 管理多个 Cache 区域。</p>
<p>1、引入 SpringCache 和 Redis(此项目使用 Redis 作为缓存) 的启动类依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、编写相关配置：</p>
<p>1）初始化自动配置：CacheAutoConfiguration 会根据选择器导入 <code>RedisCacheConfiguration</code> ，内部自动注入了 <code>RedisCacheManager</code> 。</p>
<p>2）需要手动配置的 Redis 信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">    <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="comment"># 配置使用 Redis 作为缓存</span></span><br><span class="line">    <span class="attr">redis:</span> </span><br><span class="line">        <span class="attr">host:</span> <span class="number">8.142</span><span class="number">.92</span><span class="number">.222</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">6666</span></span><br></pre></td></tr></table></figure>

<p>3）主启动类添加注解 <code>@EnableCaching</code> 。</p>
<p>4）在需要的分类上标注 <code>@Cacheable</code> 注解，代表当前方法的结果需要缓存，并且能够实现如果缓存有就不会调用方法，如果没有缓存就会调用方法并将方法执行结果放入缓存。但是<code>需要标注缓存的分区</code>，用于指定缓存数据应该放到哪个名字的缓存，推荐按照业务类型分区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CategoryServiceImpl</span></span><br><span class="line"><span class="comment"> * 查询所有的一级分类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一级分类集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &#123;&quot;category&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title function_">getLevel1Categories</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;CategoryEntity&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;parent_cid&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.selectList(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认设置：使用 Cacheable 不做其他设置时默认生成的缓存的 key 为 <code>SimpleKey</code>，而 value 的值默认是使用 <code>JDK自带序列化后的数据</code>，并且默认的过期时间 <code>ttl = -1</code>，也就是<code>永不过期</code>。</p>
</blockquote>
<p>5）因此需要自定义一些信息：</p>
<p>设置指定 key 名称，可接受 SpEl 表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(cacheNames = &#123;&quot;category&quot;&#125;, key = &quot;&#x27;level1Categories&#x27;&quot;)</span></span><br></pre></td></tr></table></figure>

<p>设置过期时间 TTL：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">    <span class="attr">cache:</span></span><br><span class="line">    	<span class="string">redis：</span> </span><br><span class="line">        	<span class="attr">time-to-live:</span> <span class="number">360000</span>   <span class="comment"># ms 为单位</span></span><br></pre></td></tr></table></figure>

<p>将数据保存为 Json 格式，而非默认的Jdk序列化格式，则需要在容器中放一个 <code>RedisCacheConfiguration</code> ，来替换原本的 <code>默认配置 defaultCacheConfig</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span>  <span class="comment">//开启属性配置绑定功能(CacheProperties 并不在 IOC 中)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedisCacheConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span>&#123;</span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">//指定 key 的序列化方式：StringRedisSerializer</span></span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()));</span><br><span class="line">        <span class="comment">//指定 value 的序列化方式：GenericJackson2JsonRedisSerializer，也可以使用引入的 fastjson 序列化</span></span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line">        <span class="comment">//配置这个后原本的配置文件配置失效,因此需要将原来的 CacheProperties 重新进行配置(下面的部分就是原本的默认配置，现在配置是为了实现配置文件配置有效性)</span></span><br><span class="line">        CacheProperties.<span class="type">Redis</span> <span class="variable">redisProperties</span> <span class="operator">=</span> cacheProperties.getRedis();</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.prefixKeysWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他还有一些个性化的设置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">360000</span></span><br><span class="line">      <span class="attr">key-prefix:</span> <span class="string">CACHE_</span>    <span class="comment"># 配置缓存key名称的前缀，如果没指定就默认使用配置缓存的 &quot;名称+::&quot;</span></span><br><span class="line">      <span class="attr">use-key-prefix:</span> <span class="literal">true</span>  <span class="comment"># 配置是否使用前缀</span></span><br><span class="line">      <span class="attr">cache-null-values:</span> <span class="literal">true</span> <span class="comment"># 是否缓存空值，防止缓存穿透</span></span><br></pre></td></tr></table></figure>

<p>6）上述是读模式下的缓存实现，那么更新数据时怎么实现缓存一致性呢？双写模式还是失效模式呢(<code>实际上使用的失效模式</code>)？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;category&quot;, key = &quot;&#x27;level1Categories&#x27;&quot;)</span>     <span class="comment">//失效模式的使用</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDetail</span><span class="params">(CategoryEntity category)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.updateById(category);</span><br><span class="line">    categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7）修改原来的查询所有菜单数据的方法为使用 SpringCache：实际就是在最初的 getCatelogJson 方法上添加注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;category&quot;&#125;, key = &quot;#root.methodName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatelogJson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//将数据库的信息一次性查出来</span></span><br><span class="line">    List&lt;CategoryEntity&gt; selectList = <span class="built_in">this</span>.baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//1.查出所有一级分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; level1Categories = <span class="built_in">this</span>.getParent_cid(selectList, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//2.封装数据</span></span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; cateMenuMap = level1Categories.stream().collect(Collectors.toMap(</span><br><span class="line">        level1Category -&gt; level1Category.getCatId().toString(),</span><br><span class="line">        level1Category -&gt; &#123;</span><br><span class="line">            <span class="comment">//2.1 根据每一个一级分类查询对应的二级分类信息数据,使用 getParent_cid 方法获取数据</span></span><br><span class="line">            List&lt;CategoryEntity&gt; categoryEntities = <span class="built_in">this</span>.getParent_cid(selectList, level1Category.getCatId());</span><br><span class="line">            <span class="comment">//2.2 封装上面的二级分类信息到最终结果中</span></span><br><span class="line">            List&lt;Catelog2Vo&gt; catelog2Vos = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (categoryEntities != <span class="literal">null</span>) &#123;</span><br><span class="line">                catelog2Vos = categoryEntities.stream().map(level2Cate -&gt; &#123;</span><br><span class="line">                    <span class="type">Catelog2Vo</span> <span class="variable">catelog2Vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Catelog2Vo</span>(</span><br><span class="line">                        level2Cate.getCatId().toString(),</span><br><span class="line">                        level2Cate.getName(),</span><br><span class="line">                        level1Category.getCatId().toString(),</span><br><span class="line">                        <span class="literal">null</span></span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">//2.3 寻找二级分类的三级分类信息进行封装,使用 getParent_cid 方法获取数据</span></span><br><span class="line">                    List&lt;CategoryEntity&gt; level3CateList = <span class="built_in">this</span>.getParent_cid(selectList, level2Cate.getCatId());</span><br><span class="line">                    <span class="keyword">if</span> (level3CateList != <span class="literal">null</span>) &#123;</span><br><span class="line">                        List&lt;Catelog2Vo.Catalog3Vo&gt; level3Cats = level3CateList.stream().map(level3Cate -&gt; &#123;</span><br><span class="line">                            Catelog2Vo.<span class="type">Catalog3Vo</span> <span class="variable">catalog3Vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Catelog2Vo</span>.Catalog3Vo(</span><br><span class="line">                                level2Cate.getCatId().toString(),</span><br><span class="line">                                level3Cate.getCatId().toString(),</span><br><span class="line">                                level3Cate.getName()</span><br><span class="line">                            );</span><br><span class="line">                            <span class="keyword">return</span> catalog3Vo;</span><br><span class="line">                        &#125;).collect(Collectors.toList());</span><br><span class="line">                        catelog2Vo.setCatalog3List(level3Cats);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> catelog2Vo;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> catelog2Vos;</span><br><span class="line">        &#125;));</span><br><span class="line">    <span class="keyword">return</span> cateMenuMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8）实际上更新菜单时需要删除这两个缓存数据，因此不能使用单一的 CacheEvict 注解，而应该使用 <code>Caching 同时进行多种缓存操作</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123;</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;, key = &quot;&#x27;level1Categories&#x27;&quot;),</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;, key = &quot;&#x27;getCatelogJson&#x27;&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>双写模式则使用 <code>@CachePut</code> 注解，失效模式使用 <code>@CacheEvict</code> 注解。</p>
</blockquote>
<p><code>[分析]</code> 实际上 SpringCache 也存在一些不足之处：</p>
<p>1）缓存穿透：使用 <code>cache-null-values: true</code> 实现。</p>
<p>2）缓存击穿：SpringCache 的 CacheManager (RedisCacheManager) 可以生成很多 Cache (RedisCache) 组件负责缓存的读取，而其内部的 <code>put</code> 方法放入缓存并没有加锁，因此如果还要使用 SpringCache 的方案，那么就需要在对应的缓存方法上添加注解属性 <code>sync</code>，就会使用有锁的 <code>get</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(cacheNames = &#123;&quot;category&quot;&#125;, key = &quot;#root.method.name&quot;, sync = true)</span></span><br></pre></td></tr></table></figure>

<p>3）缓存雪崩：指定过期时间 + 随机值来解决。</p>
<p><code>[总结]</code> 因此 SpringCache 在读模式下表现还可以，但写模式并没有加锁处理，这也就说明：常规数据（读多写少，及时性一致性要求不高的情况下）完全可以使用 SpringCache，写模式下只需要设置缓存的过期时间就足够。而针对特殊数据则需要进行特殊处理。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://localhost:4000">moon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://localhost:4000/2022/10/23/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/">http://localhost:4000/2022/10/23/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%BC%93%E5%AD%98%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://localhost:4000" target="_blank">月の子豚小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a><a class="post-meta__tags" href="/tags/Spring-Cache/">Spring Cache</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/19/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E5%89%8D%E7%AB%AF%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/"><img class="prev-cover" src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">谷粒商城-用户商城系统首页处理</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/24/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%9C%E7%B4%A2%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86/"><img class="next-cover" src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">谷粒商城-用户搜索业务处理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/17/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E4%BB%93%E5%82%A8%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97/" title="谷粒商城-仓储服务模块"><img class="cover" src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-17</div><div class="title">谷粒商城-仓储服务模块</div></div></a></div><div><a href="/2022/10/24/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%9C%E7%B4%A2%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86/" title="谷粒商城-用户搜索业务处理"><img class="cover" src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-24</div><div class="title">谷粒商城-用户搜索业务处理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic1.imgdb.cn/item/6337ca6e16f2c2beb17d8731.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">moon</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>月の子豚小屋</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/xxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1963885633@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/1963885633" target="_blank" title="QQ"><i class="fa-sharp fa-solid fa-ghost"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">月の子豚小屋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">Redis 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%90%88-Redis"><span class="toc-number">1.1.</span> <span class="toc-text">整合 Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88"><span class="toc-number">1.2.</span> <span class="toc-text">缓存失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson-%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">Redisson 方案实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">缓存一致性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCache"><span class="toc-number">2.</span> <span class="toc-text">SpringCache</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/06/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/" title="谷粒商城-订单服务实现"><img src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="谷粒商城-订单服务实现"/></a><div class="content"><a class="title" href="/2022/11/06/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/" title="谷粒商城-订单服务实现">谷粒商城-订单服务实现</a><time datetime="2022-11-06T14:42:44.735Z" title="发表于 2022-11-06 22:42:44">2022-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/03/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/" title="谷粒商城-购物车逻辑实现"><img src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="谷粒商城-购物车逻辑实现"/></a><div class="content"><a class="title" href="/2022/11/03/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/" title="谷粒商城-购物车逻辑实现">谷粒商城-购物车逻辑实现</a><time datetime="2022-11-03T07:19:16.711Z" title="发表于 2022-11-03 15:19:16">2022-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/30/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E5%A4%84%E7%90%86/" title="谷粒商城-用户认证处理"><img src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="谷粒商城-用户认证处理"/></a><div class="content"><a class="title" href="/2022/10/30/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E5%A4%84%E7%90%86/" title="谷粒商城-用户认证处理">谷粒商城-用户认证处理</a><time datetime="2022-10-30T02:15:21.954Z" title="发表于 2022-10-30 10:15:21">2022-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%94%A8%E6%88%B7%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E5%A4%84%E7%90%86/" title="谷粒商城-用户商品详情处理"><img src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="谷粒商城-用户商品详情处理"/></a><div class="content"><a class="title" href="/2022/10/28/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E7%94%A8%E6%88%B7%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E5%A4%84%E7%90%86/" title="谷粒商城-用户商品详情处理">谷粒商城-用户商品详情处理</a><time datetime="2022-10-28T08:39:51.722Z" title="发表于 2022-10-28 16:39:51">2022-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%9C%E7%B4%A2%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86/" title="谷粒商城-用户搜索业务处理"><img src="https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="谷粒商城-用户搜索业务处理"/></a><div class="content"><a class="title" href="/2022/10/24/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E6%90%9C%E7%B4%A2%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86/" title="谷粒商城-用户搜索业务处理">谷粒商城-用户搜索业务处理</a><time datetime="2022-10-24T14:24:27.926Z" title="发表于 2022-10-24 22:24:27">2022-10-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://w.wallhaven.cc/full/m9/wallhaven-m9873y.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By moon</div><div class="footer_custom_text">Hi, welcome to <a href="">月の子豚小屋</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'W7dceLXrUuiCITXy8cfM3sQ5-gzGzoHsz',
      appKey: 'Cu1minmiIoZRLGrJNxHnhZgn',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-mini="true" data-fixed="true" data-autoplay="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>